<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RECC MVP 1.6 - Recursive Reflection Visualization</title>
    <!-- Bootstrap -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- D3.js -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <!-- Socket.IO -->
    <script src="https://cdn.socket.io/4.5.0/socket.io.min.js"></script>
    <style>
        body { padding: 20px; }
        .card { margin-bottom: 20px; }
        .recursive-level {
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
            background-color: #f8f9fa;
            transition: all 0.3s;
        }
        .recursive-level.active {
            background-color: #d1e7dd;
            box-shadow: 0 0 10px rgba(0, 128, 0, 0.3);
        }
        .recursive-level.inactive {
            background-color: #f8f9fa;
            opacity: 0.7;
        }
        .concept-node {
            cursor: pointer;
            transition: all 0.3s;
        }
        .concept-node:hover {
            stroke: #ff6600;
            stroke-width: 3px;
        }
        .concept-link {
            stroke: #999;
            stroke-opacity: 0.6;
        }
        .level-indicator {
            position: absolute;
            right: 10px;
            top: 10px;
            padding: 5px 10px;
            border-radius: 15px;
            font-weight: bold;
        }
        .threshold-marker {
            stroke: blue;
            stroke-width: 2;
            stroke-dasharray: 5,5;
        }
        .effective-depth-marker {
            stroke: red;
            stroke-width: 2;
        }
        .metrics-table td, .metrics-table th {
            padding: 5px 10px;
        }
        .status-badge {
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 12px;
        }
        .status-pass {
            background-color: #d1e7dd;
            color: #0f5132;
        }
        .status-fail {
            background-color: #f8d7da;
            color: #842029;
        }
    </style>
</head>
<body>
    <div class="container-fluid">
        <h1 class="mb-4">RECC MVP 1.6 - Recursive Reflection Visualization</h1>
        
        <div class="row">
            <!-- Control Panel -->
            <div class="col-md-3">
                <div class="card">
                    <div class="card-header">Controls</div>
                    <div class="card-body">
                        <div class="mb-3">
                            <label for="cycleCount" class="form-label">Cycles</label>
                            <input type="number" class="form-control" id="cycleCount" value="10" min="1" max="100">
                        </div>
                        <button id="runCyclesBtn" class="btn btn-primary mb-3">Run Cycles</button>
                        <button id="stopCyclesBtn" class="btn btn-danger mb-3">Stop</button>
                        
                        <hr>
                        
                        <div class="mb-3">
                            <label for="promptInput" class="form-label">Custom Prompt</label>
                            <textarea class="form-control" id="promptInput" rows="3" placeholder="Enter prompt to stimulate recursive thinking..."></textarea>
                        </div>
                        <button id="sendPromptBtn" class="btn btn-success mb-3">Send Prompt</button>
                        
                        <hr>
                        
                        <div id="statusPanel" class="alert alert-info">
                            Ready
                        </div>
                    </div>
                </div>
                
                <div class="card mt-3">
                    <div class="card-header">Performance Metrics</div>
                    <div class="card-body">
                        <table class="metrics-table">
                            <tr>
                                <td>Effective Depth:</td>
                                <td id="effectiveDepth">0.0</td>
                                <td><span id="depthStatus" class="status-badge">-</span></td>
                            </tr>
                            <tr>
                                <td>Self-Model Stability:</td>
                                <td id="modelStability">0%</td>
                                <td><span id="stabilityStatus" class="status-badge">-</span></td>
                            </tr>
                            <tr>
                                <td>Cross-Level Mods:</td>
                                <td id="crossLevelMods">0</td>
                                <td><span id="modsStatus" class="status-badge">-</span></td>
                            </tr>
                            <tr>
                                <td>Concept Hierarchy:</td>
                                <td id="conceptHierarchy">0</td>
                                <td><span id="hierarchyStatus" class="status-badge">-</span></td>
                            </tr>
                            <tr>
                                <td>Meta-Strategy Evolution:</td>
                                <td id="strategyEvolution">0</td>
                                <td><span id="evolutionStatus" class="status-badge">-</span></td>
                            </tr>
                        </table>
                    </div>
                </div>
                
                <div class="card mt-3">
                    <div class="card-header">Interaction History</div>
                    <div class="card-body">
                        <div id="interactionHistory" style="height: 300px; overflow-y: auto;">
                            <!-- Interaction history will be added here -->
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Main Visualization Area -->
            <div class="col-md-9">
                <!-- Recursive Depth Visualization -->
                <div class="card">
                    <div class="card-header">Recursive Reflection Depth</div>
                    <div class="card-body">
                        <div id="recursiveDepthViz" style="height: 400px;"></div>
                    </div>
                </div>
                
                <!-- Concept Hierarchy Visualization -->
                <div class="card mt-4">
                    <div class="card-header">Concept Hierarchy</div>
                    <div class="card-body">
                        <div id="conceptHierarchyViz" style="height: 400px;"></div>
                    </div>
                </div>
                
                <!-- Meta-Strategy Evolution Chart -->
                <div class="card mt-4">
                    <div class="card-header">Meta-Strategy Evolution</div>
                    <div class="card-body">
                        <div id="strategyEvolutionViz" style="height: 300px;"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Socket.IO setup
            const socket = io();
            let recursiveData = null;
            let performanceMetrics = null;
            
            // UI elements
            const statusPanel = document.getElementById('statusPanel');
            const interactionHistory = document.getElementById('interactionHistory');
            
            // Socket connection handling
            socket.on('connect', () => {
                updateStatus('Connected to server');
            });
            
            socket.on('disconnect', () => {
                updateStatus('Disconnected from server', 'alert-danger');
            });
            
            socket.on('error', (data) => {
                updateStatus('Error: ' + data.message, 'alert-danger');
            });
            
            socket.on('status', (data) => {
                updateStatus(data.status);
            });
            
            // Handle recursive reflection data updates
            socket.on('recursive_reflection_update', (data) => {
                recursiveData = data;
                updateRecursiveDepthVisualization(data);
            });
            
            // Handle concept hierarchy updates
            socket.on('concept_hierarchy_update', (data) => {
                updateConceptHierarchyVisualization(data);
            });
            
            // Handle performance metrics updates
            socket.on('performance_update', (data) => {
                performanceMetrics = data;
                updatePerformanceMetrics(data);
            });
            
            // Handle prompt processing
            socket.on('prompt_processed', (data) => {
                addInteractionToHistory(data.prompt, data.response);
            });
            
            // Handle cycle completion
            socket.on('cycle_complete', (data) => {
                updateStatus(`Cycle ${data.cycle_id} completed`);
            });
            
            // Control button handlers
            document.getElementById('runCyclesBtn').addEventListener('click', () => {
                const cycles = parseInt(document.getElementById('cycleCount').value) || 10;
                socket.emit('start_autonomous', { steps: cycles });
                updateStatus(`Starting ${cycles} autonomous cycles...`);
            });
            
            document.getElementById('stopCyclesBtn').addEventListener('click', () => {
                socket.emit('stop_simulation');
                updateStatus('Stopping cycles...');
            });
            
            document.getElementById('sendPromptBtn').addEventListener('click', () => {
                const prompt = document.getElementById('promptInput').value.trim();
                if (prompt) {
                    socket.emit('send_prompt', { prompt });
                    updateStatus(`Sent prompt: "${prompt}"`);
                    document.getElementById('promptInput').value = '';
                } else {
                    updateStatus('Please enter a prompt', 'alert-warning');
                }
            });
            
            // Helper functions
            function updateStatus(message, className = 'alert-info') {
                statusPanel.className = 'alert ' + className;
                statusPanel.textContent = message;
            }
            
            function addInteractionToHistory(prompt, response) {
                const entry = document.createElement('div');
                entry.className = 'mb-3 p-2 border-bottom';
                
                const promptEl = document.createElement('div');
                promptEl.className = 'mb-2';
                promptEl.innerHTML = `<strong>Prompt:</strong> ${prompt}`;
                
                const responseEl = document.createElement('div');
                responseEl.className = 'text-muted';
                responseEl.innerHTML = `<strong>Response:</strong> ${response.substring(0, 100)}...`;
                
                entry.appendChild(promptEl);
                entry.appendChild(responseEl);
                interactionHistory.prepend(entry);
                
                // Limit history to 10 entries
                while (interactionHistory.children.length > 10) {
                    interactionHistory.removeChild(interactionHistory.lastChild);
                }
            }
            
            // Visualization functions
            function updateRecursiveDepthVisualization(data) {
                if (!data || !data.levels) return;
                
                const container = d3.select("#recursiveDepthViz");
                container.html(""); // Clear previous content
                
                const width = container.node().getBoundingClientRect().width;
                const height = 400;
                const levelWidth = width / (data.levels.length + 1);
                
                // Create SVG
                const svg = container.append("svg")
                    .attr("width", width)
                    .attr("height", height);
                
                // Define arrow marker
                svg.append("defs").append("marker")
                    .attr("id", "arrowhead")
                    .attr("viewBox", "0 -5 10 10")
                    .attr("refX", 5)
                    .attr("refY", 0)
                    .attr("orient", "auto")
                    .attr("markerWidth", 6)
                    .attr("markerHeight", 6)
                    .append("path")
                    .attr("d", "M0,-5L10,0L0,5")
                    .attr("fill", "#333");
                
                // Add cognitive threshold line
                svg.append("line")
                    .attr("class", "threshold-marker")
                    .attr("x1", 0)
                    .attr("y1", height - 150)
                    .attr("x2", width)
                    .attr("y2", height - 150)
                    .attr("stroke", "blue")
                    .attr("stroke-width", 2)
                    .attr("stroke-dasharray", "5,5");
                
                // Add threshold label
                svg.append("text")
                    .attr("x", width - 150)
                    .attr("y", height - 160)
                    .attr("text-anchor", "end")
                    .attr("fill", "blue")
                    .text("Cognitive Threshold (n ≥ 3)");
                
                // Create rectangles for each level
                const levels = svg.selectAll("g.level")
                    .data(data.levels)
                    .enter()
                    .append("g")
                    .attr("class", "level")
                    .attr("transform", (d, i) => `translate(${i * levelWidth + 20}, 0)`);
                
                // Add rectangles
                levels.append("rect")
                    .attr("x", 10)
                    .attr("y", d => height - 50 - d.history_entries * 20)
                    .attr("width", levelWidth - 30)
                    .attr("height", d => d.history_entries * 20 + 40)
                    .attr("fill", d => d.state === "active" ? "#69b3a2" : "#cccccc")
                    .attr("opacity", 0.8)
                    .attr("stroke", "#333")
                    .attr("stroke-width", 1)
                    .attr("rx", 5)
                    .attr("ry", 5);
                
                // Add level labels
                levels.append("text")
                    .attr("x", levelWidth / 2 - 5)
                    .attr("y", height - 25)
                    .attr("text-anchor", "middle")
                    .text((d) => `Level ${d.depth}`);
                
                // Add entry count
                levels.append("text")
                    .attr("x", levelWidth / 2 - 5)
                    .attr("y", d => height - 60 - d.history_entries * 20)
                    .attr("text-anchor", "middle")
                    .attr("fill", "#333")
                    .text(d => `${d.history_entries} entries`);
                
                // Add state indicator
                levels.append("text")
                    .attr("x", levelWidth / 2 - 5)
                    .attr("y", height - 5)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "12px")
                    .attr("fill", d => d.state === "active" ? "#0f5132" : "#6c757d")
                    .text(d => d.state);
                
                // Add arrows between levels
                for (let i = 0; i < data.levels.length - 1; i++) {
                    svg.append("line")
                        .attr("x1", (i + 0.8) * levelWidth + 15)
                        .attr("y1", height / 2)
                        .attr("x2", (i + 1.2) * levelWidth + 15)
                        .attr("y2", height / 2)
                        .attr("stroke", "#333")
                        .attr("stroke-width", 2)
                        .attr("marker-end", "url(#arrowhead)");
                }
                
                // Add effective depth line
                const effectiveDepth = data.effective_depth;
                svg.append("line")
                    .attr("class", "effective-depth-marker")
                    .attr("x1", effectiveDepth * levelWidth)
                    .attr("y1", 20)
                    .attr("x2", effectiveDepth * levelWidth)
                    .attr("y2", height - 20)
                    .attr("stroke", "red")
                    .attr("stroke-width", 2);
                
                // Add effective depth label
                svg.append("text")
                    .attr("x", effectiveDepth * levelWidth - 10)
                    .attr("y", 40)
                    .attr("text-anchor", "end")
                    .attr("fill", "red")
                    .text(`Effective Depth: ${effectiveDepth.toFixed(1)}`);
                
                // Add cross-level modifications count
                svg.append("text")
                    .attr("x", 20)
                    .attr("y", 30)
                    .attr("text-anchor", "start")
                    .text(`Cross-Level Modifications: ${data.cross_level_modifications}`);
            }
            
            function updateConceptHierarchyVisualization(data) {
                if (!data) return;
                
                const container = d3.select("#conceptHierarchyViz");
                container.html(""); // Clear previous content
                
                const width = container.node().getBoundingClientRect().width;
                const height = 400;
                
                // Create hierarchical layout
                const hierarchicalData = processHierarchicalData(data);
                
                // Create SVG
                const svg = container.append("svg")
                    .attr("width", width)
                    .attr("height", height);
                
                // Create hierarchical tree layout
                const treeLayout = d3.tree()
                    .size([width - 100, height - 60]);
                
                // Create root hierarchy
                const root = d3.hierarchy(hierarchicalData);
                
                // Apply layout to hierarchy
                treeLayout(root);
                
                // Create links
                svg.selectAll("path.link")
                    .data(root.links())
                    .enter()
                    .append("path")
                    .attr("class", "link")
                    .attr("d", d3.linkHorizontal()
                        .x(d => d.y + 50) // Swap x and y for horizontal layout
                        .y(d => d.x + 30))
                    .attr("fill", "none")
                    .attr("stroke", "#999")
                    .attr("stroke-width", 1.5);
                
                // Create nodes
                const nodes = svg.selectAll("g.node")
                    .data(root.descendants())
                    .enter()
                    .append("g")
                    .attr("class", "node")
                    .attr("transform", d => `translate(${d.y + 50}, ${d.x + 30})`);
                
                // Add circles for nodes
                nodes.append("circle")
                    .attr("r", d => 5 + d.data.size * 2)
                    .attr("fill", d => getHierarchyLevelColor(d.depth));
                
                // Add labels for nodes
                nodes.append("text")
                    .attr("dx", 12)
                    .attr("dy", 4)
                    .attr("text-anchor", "start")
                    .text(d => d.data.name)
                    .attr("font-size", d => 12 + d.data.size);
                
                // Add depth level indicator
                svg.append("text")
                    .attr("x", 20)
                    .attr("y", 20)
                    .attr("text-anchor", "start")
                    .text(`Hierarchy Depth: ${getMaxHierarchyDepth(hierarchicalData)}`);
            }
            
            function updateStrategyEvolutionVisualization(data) {
                if (!data || !data.strategies) return;
                
                const container = d3.select("#strategyEvolutionViz");
                container.html(""); // Clear previous content
                
                const width = container.node().getBoundingClientRect().width;
                const height = 300;
                const margin = { top: 20, right: 30, bottom: 40, left: 60 };
                
                // Create SVG
                const svg = container.append("svg")
                    .attr("width", width)
                    .attr("height", height);
                
                // Create scales
                const x = d3.scaleTime()
                    .domain([d3.min(data.timepoints), d3.max(data.timepoints)])
                    .range([margin.left, width - margin.right]);
                    
                const y = d3.scaleLinear()
                    .domain([0, 1])
                    .nice()
                    .range([height - margin.bottom, margin.top]);
                
                // Add axes
                svg.append("g")
                    .attr("transform", `translate(0,${height - margin.bottom})`)
                    .call(d3.axisBottom(x));
                    
                svg.append("g")
                    .attr("transform", `translate(${margin.left},0)`)
                    .call(d3.axisLeft(y));
                
                // Add axes labels
                svg.append("text")
                    .attr("x", width / 2)
                    .attr("y", height - 5)
                    .attr("text-anchor", "middle")
                    .text("Time");
                    
                svg.append("text")
                    .attr("transform", "rotate(-90)")
                    .attr("x", -height / 2)
                    .attr("y", 15)
                    .attr("text-anchor", "middle")
                    .text("Strategy Values");
                
                // Create line generator
                const line = d3.line()
                    .x((d, i) => x(data.timepoints[i]))
                    .y(d => y(d));
                
                // Add lines for each strategy
                Object.entries(data.strategies).forEach(([strategy, values], i) => {
                    const color = d3.schemeCategory10[i % 10];
                    
                    svg.append("path")
                        .datum(values)
                        .attr("fill", "none")
                        .attr("stroke", color)
                        .attr("stroke-width", 2)
                        .attr("d", line);
                        
                    // Add strategy label at end of line
                    svg.append("text")
                        .attr("x", x(data.timepoints[data.timepoints.length - 1]) + 5)
                        .attr("y", y(values[values.length - 1]))
                        .attr("fill", color)
                        .attr("font-size", 12)
                        .text(strategy);
                });
            }
            
            function updatePerformanceMetrics(data) {
                if (!data) return;
                
                // Update metrics display
                document.getElementById('effectiveDepth').textContent = data.effective_recursive_depth.toFixed(1);
                document.getElementById('modelStability').textContent = (data.self_model_stability * 100).toFixed(1) + '%';
                document.getElementById('crossLevelMods').textContent = data.modification_rate_per_100_cycles.toFixed(1) + '/100';
                document.getElementById('conceptHierarchy').textContent = data.concept_hierarchy_depth.toFixed(1);
                document.getElementById('strategyEvolution').textContent = data.meta_strategy_evolution ? 'True' : 'False';
                
                // Update status indicators
                updateStatusBadge('depthStatus', data.effective_recursive_depth >= 3.0);
                updateStatusBadge('stabilityStatus', data.self_model_stability >= 0.8);
                updateStatusBadge('modsStatus', data.modification_rate_per_100_cycles >= 10);
                updateStatusBadge('hierarchyStatus', data.concept_hierarchy_depth >= 3);
                updateStatusBadge('evolutionStatus', data.meta_strategy_evolution);
            }
            
            function updateStatusBadge(elementId, isPassing) {
                const element = document.getElementById(elementId);
                element.textContent = isPassing ? 'PASS' : 'FAIL';
                element.className = isPassing ? 'status-badge status-pass' : 'status-badge status-fail';
            }
            
            // Helper functions for concept hierarchy visualization
            function processHierarchicalData(data) {
                // Sample transformation - replace with actual data processing
                // In a real implementation, this would transform the flat concept data
                // into a hierarchical structure for visualization
                
                return {
                    name: "Root",
                    size: 3,
                    children: [
                        { 
                            name: "Abstract Concepts", 
                            size: 2,
                            children: [
                                { name: "Meta-cognition", size: 2 },
                                { name: "Self-reference", size: 3 },
                                { name: "Recursion", size: 2 }
                            ]
                        },
                        {
                            name: "Concrete Concepts",
                            size: 2, 
                            children: [
                                { name: "Memory", size: 2 },
                                { name: "Pattern", size: 1 },
                                { 
                                    name: "Reflection", 
                                    size: 2,
                                    children: [
                                        { name: "Observation", size: 1 },
                                        { name: "Analysis", size: 1 }
                                    ]
                                }
                            ]
                        }
                    ]
                };
            }
            
            function getHierarchyLevelColor(depth) {
                const colors = ['#3366cc', '#dc3912', '#ff9900', '#109618', '#990099', '#0099c6'];
                return colors[depth % colors.length];
            }
            
            function getMaxHierarchyDepth(node, currentDepth = 0) {
                let maxDepth = currentDepth;
                if (node.children) {
                    for (const child of node.children) {
                        const childDepth = getMaxHierarchyDepth(child, currentDepth + 1);
                        maxDepth = Math.max(maxDepth, childDepth);
                    }
                }
                return maxDepth;
            }
        });
    </script>
</body>
</html>